{
  "version": 3,
  "sources": ["../../profanity-cleaner/dist/webpack:/profanityCleaner/webpack/universalModuleDefinition", "../../profanity-cleaner/dist/webpack:/profanityCleaner/src/index.js", "../../profanity-cleaner/dist/webpack:/profanityCleaner/webpack/bootstrap", "../../profanity-cleaner/dist/webpack:/profanityCleaner/webpack/startup"],
  "sourcesContent": ["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"profanityCleaner\"] = factory();\n\telse\n\t\troot[\"profanityCleaner\"] = factory();\n})(this, () => {\nreturn ", "/* eslint-disable max-len */\nconst defaultBadWords = require('./badWords.json');\n\n/**\n * A function to censor bad words in a given text.\n *\n * @param {string} text - The input text to be censored.\n * @param {Object} [option={}] - The options object for censoring the text.\n * @param {string} [options.placeholder='*'] - The character to replace bad words with.\n * @param {boolean} [options.caseSensitive=false] - Whether to consider the case of the words while censoring.\n * @param {boolean} [options.wholeWordsOnly=true] - Whether to consider only whole words while censoring.\n * @param {string[]} [options.exceptions=[]] - An array of words that should not be censored.\n * @param {boolean} [options.keepFirstAndLastChar=false] - Whether to keep the first and last characters of the bad words while censoring.\n * @param {function} [options.customReplacement=null] - A custom function to replace bad words. The function should take in a single argument (the bad word) and return the replacement string.\n * @param {boolean} [options.replacePartialWords=false] - Whether to consider partial words while censoring.\n * @param {boolean} [options.includePunctuation=false] - Whether to keep the punctuation at the beginning and end of the bad words while censoring.\n * @param {number} [options.minimumWordLength=1] - The minimum length of a word that should be censored.\n * @param {function} [options.customMatch=null] - A custom function to decide which words should be censored. The function should take in a single argument (the bad word) and return a boolean value indicating whether the word should be censored.\n * @param {string[]} [options.customBadWords=[]] - An array of additional bad words to censor.\n * @returns {string} The censored text.\n *\n * @example\n *\n * const profanityCleaner = clean('This is a fucking example.');\n * console.log(profanityCleaner); // Output: \"This is a ******* example.\"\n */\n\nfunction clean(text, options = {}) {\n  // Set default options\n  const defaultOptions = {\n    placeholder: '*',\n    caseSensitive: false,\n    wholeWordsOnly: true,\n    exceptions: [],\n    keepFirstAndLastChar: false,\n    customReplacement: null,\n    replacePartialWords: false,\n    includePunctuation: false,\n    minimumWordLength: 1,\n    customMatch: null,\n    customBadWords: [],\n  };\n\n  const option = {\n    ...defaultOptions,\n    ...options,\n  };\n\n  const censoredWords = [...defaultBadWords, ...option.customBadWords ].map((word) => word.replace(/\\*/g, '\\\\w+'));\n\n  // console.log(censoredWords);\n\n  // Create a regular expression based on the options\n  let regex = new RegExp(censoredWords.join('|'), 'g');\n\n  if (!option.caseSensitive) {\n    regex = new RegExp(censoredWords.join('|'), 'gi');\n  }\n  if (option.wholeWordsOnly) {\n    regex = new RegExp(`\\\\b(${censoredWords.join('|')})\\\\b`, 'gi');\n  }\n  if (option.replacePartialWords) {\n    regex = new RegExp(censoredWords.join('|'), 'gi');\n  }\n\n  // console.log(regex);\n\n  // Replace the censored words with the censor character or custom replacement\n  return text.replace(regex, (match) => {\n    // Check if the word is shorter than the minimum length\n    if (match.length < option.minimumWordLength) {\n      return match;\n    }\n\n    // Check if the word matches the custom match function\n    if (typeof option.customMatch === 'function' && !option.customMatch(match)) {\n      return match;\n    }\n\n    // Check if the word is in the exceptions list\n    if (option.exceptions.includes(match.toLowerCase())) {\n      return match;\n    }\n\n    // Use the custom replacement function if provided\n    if (typeof option.customReplacement === 'function') {\n      return option.customReplacement(match);\n    }\n\n    // Keep the first and last characters of the word\n    if (option.keepFirstAndLastChar) {\n      return `${match[0]}${option.placeholder.repeat(match.length - 2)}${match[match.length - 1]}`;\n    }\n\n\n    // Censor the entire word\n    let censoredWord = option.placeholder.repeat(match.length);\n\n    // Keep the punctuation at the beginning and end of the word\n    if (option.includePunctuation) {\n      const firstChar = match[0];\n      const lastChar = match[match.length - 1];\n      if (firstChar.match(/[^\\w\\s]/)) {\n        censoredWord = `${firstChar}${censoredWord.substring(1)}`;\n      }\n      if (lastChar.match(/[^\\w\\s]/)) {\n        censoredWord = `${censoredWord.substring(0, censoredWord.length - 1)}${lastChar}`;\n      }\n    }\n\n    return censoredWord;\n  });\n}\n\n/**\n * A function to check if a given text contains any bad words.\n *\n * @param {string} text - The input text to check.\n *\n * @returns {Boolen}\n * */\n\nfunction isProfane(text, options = {}) {\n  const cleanedText = clean(text, options);\n  return cleanedText !== text;\n}\n\nmodule.exports = {\n  clean,\n  isProfane,\n};", "// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n", "// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(380);\n"],
  "mappings": "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",
  "names": ["root", "factory", "exports", "module", "define", "amd", "this", "e", "t", "r", "a", "n", "defaultBadWords", "require", "clean", "text", "options", "defaultOptions", "placeholder", "caseSensitive", "wholeWordsOnly", "exceptions", "keepFirstAndLastChar", "customReplacement", "replacePartialWords", "includePunctuation", "minimumWordLength", "customMatch", "customBadWords", "option", "censoredWords", "map", "word", "replace", "regex", "RegExp", "join", "match", "length", "includes", "toLowerCase", "repeat", "censoredWord", "firstChar", "lastChar", "substring", "isProfane", "cleanedText", "__webpack_module_cache__", "__webpack_require__", "moduleId", "cachedModule", "__webpack_modules__"]
}
